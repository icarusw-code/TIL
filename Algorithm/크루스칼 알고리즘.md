# 크루스칼 알고리즘

------

### 신장 트리

그래프에서 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미한다.

- 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다는 조건은 트리의 조건이기도 하다.

![](C:\Users\최성진\Desktop\프로그래밍\MarkDown\Algorithm\신장트리.JPG)

**최소 신장 트리**

- 최소한의 비용으로 구성되는 신장 트리를 찾아야 할때 
- 예를 들어 N개의 도시가 존재하는 상황에서 두 도시 사이에 도로를 놓아 **전체 도시가 서로 연결 될 수 있게** 하는 경우



### 크루스칼 알고리즘

- 최소 신장 트리 알고리즘
- 그리디 알고리즘으로 분류된다
- 구체적인 동작
  1.  간선 데이터를 비용에 따라 **오름차순으로 정렬**한다
  2. 간선을 하나씩 확인하며 <u>현재의 간선이 사이클을 발생시키는지 확인</u>한다
     1. 사이클이 발생하지 않는 경우 최소 신장 트리에 포함한다
     2. 사이클이 발생하는 경우 최소 신장트리에 포함시키지 않는다
  3. 모든 간선에 대하여 2번 과정을 반복한다

```python
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드를 찾을 때까지 재귀호출
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b
        
# 노드의 개수와 간선의 개수 입력 받기
v, e = map(int, input().split())
parent = [0] * (v + 1) #부모 테이블 초기화

# 모든 간선을 담을 리스트와, 최종 비용을 담을 변수
edges = []
result = 0

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i
    
# 모든 간선에 대한 정보를 입력 받기
for _ in range(e):
    a, b, cost = map(int, input().split())
    # 비용순으로 정렬하기 위해서 튜플의 첫 번째 원소를 비용으로 설정
    edges.append((cost, a, b))
    
# 간선을 비용순으로 정렬
edges.sort()

# 간선을 하나씩 확인하며
for edge in edges:
    cost, a, b = edge
    # 사이클이 발생하지 않는 경우에만 집합에 포함
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        result += cost
        
print(result)
```

**크루스칼 알고리즘 성능**

- 간선의 개수가 E개 일때, O(ElogE) 의 시간 복잡도를 가진다
- 크루스칼 알고리즘에서 가장 많은 시간을 요구하는 곳은 간선을 정렬하는 부분
  - 표준 라이브러리를 이용해 E개의 데이터를 정렬하기 위한 시간 복잡도는 O(ElogE)



### 위상 정렬

- <u>사이클이 없는 방향 그래프</u>의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열한것을 의미

- 진입차수(Indegree): 특정한 노드로 들어오는 간선의 개수

- 진출차수(Outdegree): 특정한 노드에서 나가는 간선의 개수

  ![](C:\Users\최성진\Desktop\프로그래밍\MarkDown\Algorithm\캡처.JPG)

- 큐를 이용하는 위상 정렬 알고리즘의 동작 과정

  1.  진입차수가 0인 모든 노드를 큐에 넣는다
  2.  큐가 빌 때까지 다음의 과정을 반복한다
     1. 큐에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거한다
     2. 새롭게 진입차수가 0이된 노드를 큐에 넣는다

  **결과적으로 각 노드가 큐에 들어온 순서가 위상 정렬을 수행한 결과와 같다**

- **위상 정렬의 특징**

  - DAG에서만 수행 할 수 있다
    - DAG(Direct Acyclic Graph): 순환하지 않는 방향 그래프
  - 위상 정렬에서는 여러 가지 답이 존재 할 수 있다
    - 한 단계에서 큐에 새롭게 들어가는 원소가 2개 이상인 경우 여러가지 답이 존재한다
  - 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재한다고 판단 할 수 있다
    - 사이클에 포함된 원소 중에서 어떠한 원소도 큐에 들어가지 못한다
  - 스택을 활용한 DFS를 이용해 위상 정렬을 수행 할 수도 있다

  

  ```python
  from collections import deque
  
  #노드의 개수와 간선의 개수를 입력받기
  v, e = map(int, input().split())
  # 모든 노드에 대한 진입차수는 0으로 초기화
  indegree = [0] * (v + 1)
  # 각 노드에 연결된 간선 정보를 담기 위한 연결 리스트 초기화
  graph = [[] for i in range(v + 1)]
  
  # 방향 그래프의 모든 간선 정보를 입력 받기
  for _ in range(e):
      a, b = map(int, input().split())
      graph[a].append(b) #정점 A에서 B로 이동 가능
      # 진입 차수를 1증가
      indegree[b] += 1
      
  # 위상 정렬 함수
  def topology_sort():
      result = [] #알고리즘 수행 결과를 담을 리스트
      q = deque() #큐 기능을 위한 deque 라이브러리 사용
      # 처음 시작할 때는 진입차수가 0인 노드를 큐에 삽입
      for i in range(1, v + 1):
          if indegree[i] == 0:
              q.apeend(i)
      # 큐가 빌 때까지 반복
      while q:
          #큐에서 원소 꺼내기
          now = q.popleft()
          result.append(now)
          #해당 원소와 연결된 노드들의 진입차수에서 1빼기
          for i in graph[now]:
              indegree[i] -= 1
              #새롭게 진입차수가 0이되는 노드를 큐에 삽입
              if indegree[i] == 0:
                  q.append(i)
  # 위상 정렬을 수행한 결과 출력
  for i in result:
      print(i, end= ' ')
      
  topology_sort()
  ```

  

