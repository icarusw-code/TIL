# **비트마스킹**

------

불리안 값으로 이루어진 집합에 대해서 굉장히 빠르게 연산하는 기법

이진탐색의 속도를 빠르게 하기위해 사용되기도 함

완전탐색일 경우 시간을 단축하기 위해서?

### 비트 연산

|  **연산자**   |                        **설명**                        |       **예시**        | **정답**  |
| :-----------: | :----------------------------------------------------: | :-------------------: | :-------: |
|    AND(&)     |             **둘 다** 1이면  1,  아니면 0              | bin(0b1101 & 0b1001)  | '0b1001'  |
|    OR(\|)     |                둘 중 **하나만** 1이면 1                | bin(0b1101 \| 0b1001) | '0b1101'  |
|    XOR(^)     |                 **다르면** 1, 같으면 0                 | bin(0b1101 ^ 0b1001)  |  '0b100'  |
|    NOT(~)     |                1은 0으로, 0은 1로 변환                 |     bin(~0b1101)      | '-0b1110' |
| 쉬프트(<<,>>) | 각 비트를 화살표 방향으로 옮긴다. <<는 2를 곱하는 효과 |      0b0011 << 2      | '0b1100'  |

### 개념

불리언배열의 역할을 하는 한 정수를 만들어서 비트 연산을 통해 탐색, 수정 드의 작업을 하는 것을 비트마스킹이라 한다.

```python
# {권은비, 김채원, 안유진, 사쿠라} 를 체크하는 모든 경우의 수
# 4C1, 4C2의 조합을 한번에 표현이 가능
# 1100 은 권은비, 김채원 을 뽑은것을 의미한다.
for i in range(1 << 4): # 총 0 - 15 까지 16가지의 경우가 나옴nu
```

```python
if i &(1 << j):
    print(arr[j], end = ' ')
# i는 찾으려는 부분집합(2진수로 변환하여 1,0 으로 이뤄진 리스트로 생각)
# j는 인덱스의 번호
# 찾으려는 부분집합과 현재 인덱스 번화 사이의 교집합이 존재하면 원본 리스트에서 그 인덱스의 요소를 출력
# 0일때는 없음 0일때는 있음
```

```python
arr = [1, 2, 3]
n = len(arr)

for i in range(1 << n):
    for j in range(n):
        if i & (1 << j):
            print(arr[i], end = ' ')
    print()
```

### 부분집합 연산

\- S에 i를 추가 : S |= (1 << i)

 \- S에서 i를 제거 : S &= ~(1 << i)

 \- S에 i가 있는지 검사 : S & (1 << i)

 \- 전체 집합은 (1<<N) - 1 로, 공집합은 0으로 나타낼 수 있다.

 \- 1 << N - 1 은 1 << (N - 1) 이라고 봐야한다.

### 비트마스크의 장점

- 공간을 적게 사용(정수 1개)ㅉ
- 정수이다. (표현하기가 쉬움)

### 사용 조건

- 0 ~ (N-1)까지 N개의 정수로 이루어진 집합(크기가 정해져 있을때)

### 한계 

int형 숫자의 한계가지 표현이 가능하므로 31까지 가능하다 

